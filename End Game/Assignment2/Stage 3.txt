secondOnes:
      MOV R1, #0        ; Initialize R1 with 0
      PUSH {R0, R1}     ; Save R0 & R1 on the stack
      BL Print
      LDR R0, .LastKeyAndReset
      CMP R0, #82       ; Compare R0 with 82 (ASCII code for 'R')
      BEQ Reset         ; Branch to reset if equal
      CMP R0, #80       ; Compare R0 with 80 (ASCII code for 'P')
      BEQ Pause         ; Branch to Pause if equal
      CMP R0, #83       ; Compare R0 with 83 (ASCII code for 'S')
      BEQ Split         ; Branch to split if equal
      LDRB R1, 0x001f1
      ADD R1, R1, #1
      STRB R1, 0x001f1
      POP {R0, R1}
      LDRB R1, 0x001f1
      CMP R1, #10
      BEQ secondTens
      BL delay
secondTens:
      MOV R1, #0        ; Reset R1 to 0 (counter for secondTens digit)
      STRB R1, 0x001f1  ; Store 0 here
      LDRB R1, 0x001f2  ; Load the value into R1
      ADD R1, R1, #1    ; Increment by 1
      STRB R1, 0x001f2  ; Store updated value
      CMP R1, #6        ; Compare R1 with 6
      BEQ minuteOnes    ; Branch to minuteOnes if equal
      BL delay
minuteOnes:
      MOV R1, #0
      STRB R1, 0x001f2
      LDRB R1, 0x001f3
      ADD R1, R1, #1
      STRB R1, 0x001f3
      CMP R1, #10
      BEQ minuteTens
      BL delay
minuteTens:
      MOV R1, #0
      STRB R1, 0x001f3
      LDRB R1, 0x001f4
      ADD R1, R1, #1
      STRB R1, 0x001f4
      CMP R1, #6
      BEQ stop
      BL delay
delay:
      PUSH {R1, R4, R5, R6} ; Save R1,R4,R5,R6 on the stack
      LDR R1, .Time     ; Load current time into R1
Time:
      MOV R5, R1        ; Copy current time into R5
      LDR R4, .Time
      SUB R6, R4, R5    ; Calculate elapsed time
      CMP R6, #1        ; Compare elapsed time with 1 (delay time)
      BLT Time
      POP {R1, R4, R5, R6}
      B secondOnes
Print:
      PUSH {R0}
      LDR R0, 0x001f4   ; minuteTens digit
      STR R0, .WriteUnsignedNum
      LDRB R0, 0x001f3  ; minuteOnes digit
      STR R0, .WriteUnsignedNum
      MOV R0, #Colon
      STR R0, .WriteString
      LDRB R0, 0x001f2  ; secondTens digit
      STR R0, .WriteUnsignedNum
      LDRB R0, 0x001f1  ; secondOnes digit
      STR R0, .WriteUnsignedNum
      MOV R0, #32
      STR R0, .WriteChar ; Write a space character
// Prints Split time
      LDR R0, minTens
      STR R0, .WriteUnsignedNum
      LDR R0, minOnes
      STR R0, .WriteUnsignedNum
      MOV R0, #Colon
      STR R0, .WriteString
      LDRB R0, secTens
      STR R0, .WriteUnsignedNum
      LDR R0, secOnes
      STR R0, .WriteUnsignedNum
      MOV R0, #NewLine
      STR R0, .WriteString
      POP {R0}
      RET
Pause:
      LDR R0, .LastKeyAndReset
      CMP R0, #82       ; Allows to reset while in Pause
      BEQ Reset
      CMP R0, #80       ; Resume stopwatch
      BEQ secondOnes
      B Pause
Reset:
      MOV R0, #0
      STR R0, 0x001f0   ; Clear stop signal
      STRB R0, 0x001f1  ; Clear secondOnes digit
      STRB R0, 0x001f2  ; Clear secondTens digit
      STRB R0, 0x001f3  ; Clear minuteOnes digit
      STRB R0, 0x001f4  ; Clear minuteTens digit
      STRB R0, minTens  ; Clear split minuteTens digit
      STRB R0, minOnes  ; Clear split minuteOnes digit
      STRB R0, secTens  ; Clear split secondTens digit
      STRB R0, secOnes  ; Clear split secondOnes digit101|      PUSH {LR}
      BL Print
      POP {LR}
      B Pause
Split:
      PUSH {R1,R2,R3,R4}
      LDRB R1, 0x001f4  ; Load values of minuteTens
      LDRB R2, 0x001f3  ; Load values of minuteOnes
      LDRB R3, 0x001f2  ; Load values of secondTens
      LDRB R4, 0x001f1  ; Load values of secondOnes
      STR R1, minTens
      STR R2, minOnes
      STR R3, secTens
      STR R4, secOnes
      POP {R1,R2, R3, R4}
      B secondOnes
// Stops the stopwatch when it reaches 99:99
stop:
      MOV R0, #0
      STR R0, 0x001f0   ; Store 0 in 0x001f0 (stop signal)
      MOV R0, #0
      STR R0, 0x001f4
      MOV R0, #0
      STR R0, 0x001f8
      MOV R0, #0
      STR R0, 0x001fc
      B secondOnes
minTens: .WORD 0
minOnes: .WORD 0
secTens: .WORD 0
secOnes: .WORD 0
NewLine: .ASCIZ "\n\n\n"
Colon: .ASCIZ ": "
